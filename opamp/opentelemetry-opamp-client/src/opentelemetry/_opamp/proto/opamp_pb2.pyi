"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
OpAMP: Open Agent Management Protocol (https://github.com/open-telemetry/opamp-spec)"""
import anyvalue_pb2
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _AgentToServerFlags:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _AgentToServerFlagsEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_AgentToServerFlags.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    AgentToServerFlags_Unspecified: _AgentToServerFlags.ValueType  # 0
    AgentToServerFlags_RequestInstanceUid: _AgentToServerFlags.ValueType  # 1
    """AgentToServerFlags is a bit mask. Values below define individual bits.

    The Agent requests Server go generate a new instance_uid, which will
    be sent back in ServerToAgent message
    """

class AgentToServerFlags(_AgentToServerFlags, metaclass=_AgentToServerFlagsEnumTypeWrapper): ...

AgentToServerFlags_Unspecified: AgentToServerFlags.ValueType  # 0
AgentToServerFlags_RequestInstanceUid: AgentToServerFlags.ValueType  # 1
"""AgentToServerFlags is a bit mask. Values below define individual bits.

The Agent requests Server go generate a new instance_uid, which will
be sent back in ServerToAgent message
"""
global___AgentToServerFlags = AgentToServerFlags

class _ServerToAgentFlags:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ServerToAgentFlagsEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ServerToAgentFlags.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ServerToAgentFlags_Unspecified: _ServerToAgentFlags.ValueType  # 0
    ServerToAgentFlags_ReportFullState: _ServerToAgentFlags.ValueType  # 1
    """Flags is a bit mask. Values below define individual bits.

    ReportFullState flag can be used by the Server if the Agent did not include the
    particular bit of information in the last status report (which is an allowed
    optimization) but the Server detects that it does not have it (e.g. was
    restarted and lost state). The detection happens using
    AgentToServer.sequence_num values.
    The Server asks the Agent to report full status.
    """
    ServerToAgentFlags_ReportAvailableComponents: _ServerToAgentFlags.ValueType  # 2
    """ReportAvailableComponents flag can be used by the server if the Agent did
    not include the full AvailableComponents message, but only the hash.
    If this flag is specified, the agent will populate available_components.components
    with a full description of the agent's components.
    Status: [Development]
    """

class ServerToAgentFlags(_ServerToAgentFlags, metaclass=_ServerToAgentFlagsEnumTypeWrapper): ...

ServerToAgentFlags_Unspecified: ServerToAgentFlags.ValueType  # 0
ServerToAgentFlags_ReportFullState: ServerToAgentFlags.ValueType  # 1
"""Flags is a bit mask. Values below define individual bits.

ReportFullState flag can be used by the Server if the Agent did not include the
particular bit of information in the last status report (which is an allowed
optimization) but the Server detects that it does not have it (e.g. was
restarted and lost state). The detection happens using
AgentToServer.sequence_num values.
The Server asks the Agent to report full status.
"""
ServerToAgentFlags_ReportAvailableComponents: ServerToAgentFlags.ValueType  # 2
"""ReportAvailableComponents flag can be used by the server if the Agent did
not include the full AvailableComponents message, but only the hash.
If this flag is specified, the agent will populate available_components.components
with a full description of the agent's components.
Status: [Development]
"""
global___ServerToAgentFlags = ServerToAgentFlags

class _ServerCapabilities:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ServerCapabilitiesEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ServerCapabilities.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ServerCapabilities_Unspecified: _ServerCapabilities.ValueType  # 0
    """The capabilities field is unspecified."""
    ServerCapabilities_AcceptsStatus: _ServerCapabilities.ValueType  # 1
    """The Server can accept status reports. This bit MUST be set, since all Server
    MUST be able to accept status reports.
    """
    ServerCapabilities_OffersRemoteConfig: _ServerCapabilities.ValueType  # 2
    """The Server can offer remote configuration to the Agent."""
    ServerCapabilities_AcceptsEffectiveConfig: _ServerCapabilities.ValueType  # 4
    """The Server can accept EffectiveConfig in AgentToServer."""
    ServerCapabilities_OffersPackages: _ServerCapabilities.ValueType  # 8
    """The Server can offer Packages.
    Status: [Beta]
    """
    ServerCapabilities_AcceptsPackagesStatus: _ServerCapabilities.ValueType  # 16
    """The Server can accept Packages status.
    Status: [Beta]
    """
    ServerCapabilities_OffersConnectionSettings: _ServerCapabilities.ValueType  # 32
    """The Server can offer connection settings.
    Status: [Beta]
    """
    ServerCapabilities_AcceptsConnectionSettingsRequest: _ServerCapabilities.ValueType  # 64
    """The Server can accept ConnectionSettingsRequest and respond with an offer.
    Status: [Development]
    """

class ServerCapabilities(_ServerCapabilities, metaclass=_ServerCapabilitiesEnumTypeWrapper): ...

ServerCapabilities_Unspecified: ServerCapabilities.ValueType  # 0
"""The capabilities field is unspecified."""
ServerCapabilities_AcceptsStatus: ServerCapabilities.ValueType  # 1
"""The Server can accept status reports. This bit MUST be set, since all Server
MUST be able to accept status reports.
"""
ServerCapabilities_OffersRemoteConfig: ServerCapabilities.ValueType  # 2
"""The Server can offer remote configuration to the Agent."""
ServerCapabilities_AcceptsEffectiveConfig: ServerCapabilities.ValueType  # 4
"""The Server can accept EffectiveConfig in AgentToServer."""
ServerCapabilities_OffersPackages: ServerCapabilities.ValueType  # 8
"""The Server can offer Packages.
Status: [Beta]
"""
ServerCapabilities_AcceptsPackagesStatus: ServerCapabilities.ValueType  # 16
"""The Server can accept Packages status.
Status: [Beta]
"""
ServerCapabilities_OffersConnectionSettings: ServerCapabilities.ValueType  # 32
"""The Server can offer connection settings.
Status: [Beta]
"""
ServerCapabilities_AcceptsConnectionSettingsRequest: ServerCapabilities.ValueType  # 64
"""The Server can accept ConnectionSettingsRequest and respond with an offer.
Status: [Development]
"""
global___ServerCapabilities = ServerCapabilities

class _PackageType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _PackageTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PackageType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PackageType_TopLevel: _PackageType.ValueType  # 0
    PackageType_Addon: _PackageType.ValueType  # 1

class PackageType(_PackageType, metaclass=_PackageTypeEnumTypeWrapper):
    """The type of the package, either an addon or a top-level package.
    Status: [Beta]
    """

PackageType_TopLevel: PackageType.ValueType  # 0
PackageType_Addon: PackageType.ValueType  # 1
global___PackageType = PackageType

class _ServerErrorResponseType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ServerErrorResponseTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ServerErrorResponseType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ServerErrorResponseType_Unknown: _ServerErrorResponseType.ValueType  # 0
    """Unknown error. Something went wrong, but it is not known what exactly.
    The Agent SHOULD NOT retry the message.
    The error_message field may contain a description of the problem.
    """
    ServerErrorResponseType_BadRequest: _ServerErrorResponseType.ValueType  # 1
    """The AgentToServer message was malformed. The Agent SHOULD NOT retry
    the message.
    """
    ServerErrorResponseType_Unavailable: _ServerErrorResponseType.ValueType  # 2
    """The Server is overloaded and unable to process the request. The Agent
    should retry the message later. retry_info field may be optionally
    set with additional information about retrying.
    """

class ServerErrorResponseType(_ServerErrorResponseType, metaclass=_ServerErrorResponseTypeEnumTypeWrapper): ...

ServerErrorResponseType_Unknown: ServerErrorResponseType.ValueType  # 0
"""Unknown error. Something went wrong, but it is not known what exactly.
The Agent SHOULD NOT retry the message.
The error_message field may contain a description of the problem.
"""
ServerErrorResponseType_BadRequest: ServerErrorResponseType.ValueType  # 1
"""The AgentToServer message was malformed. The Agent SHOULD NOT retry
the message.
"""
ServerErrorResponseType_Unavailable: ServerErrorResponseType.ValueType  # 2
"""The Server is overloaded and unable to process the request. The Agent
should retry the message later. retry_info field may be optionally
set with additional information about retrying.
"""
global___ServerErrorResponseType = ServerErrorResponseType

class _CommandType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _CommandTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_CommandType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    CommandType_Restart: _CommandType.ValueType  # 0
    """The Agent should restart. This request will be ignored if the Agent does not
    support restart.
    """

class CommandType(_CommandType, metaclass=_CommandTypeEnumTypeWrapper):
    """Status: [Beta]"""

CommandType_Restart: CommandType.ValueType  # 0
"""The Agent should restart. This request will be ignored if the Agent does not
support restart.
"""
global___CommandType = CommandType

class _AgentCapabilities:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _AgentCapabilitiesEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_AgentCapabilities.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    AgentCapabilities_Unspecified: _AgentCapabilities.ValueType  # 0
    """The capabilities field is unspecified."""
    AgentCapabilities_ReportsStatus: _AgentCapabilities.ValueType  # 1
    """The Agent can report status. This bit MUST be set, since all Agents MUST
    report status.
    """
    AgentCapabilities_AcceptsRemoteConfig: _AgentCapabilities.ValueType  # 2
    """The Agent can accept remote configuration from the Server."""
    AgentCapabilities_ReportsEffectiveConfig: _AgentCapabilities.ValueType  # 4
    """The Agent will report EffectiveConfig in AgentToServer."""
    AgentCapabilities_AcceptsPackages: _AgentCapabilities.ValueType  # 8
    """The Agent can accept package offers.
    Status: [Beta]
    """
    AgentCapabilities_ReportsPackageStatuses: _AgentCapabilities.ValueType  # 16
    """The Agent can report package status.
    Status: [Beta]
    """
    AgentCapabilities_ReportsOwnTraces: _AgentCapabilities.ValueType  # 32
    """The Agent can report own trace to the destination specified by
    the Server via ConnectionSettingsOffers.own_traces field.
    Status: [Beta]
    """
    AgentCapabilities_ReportsOwnMetrics: _AgentCapabilities.ValueType  # 64
    """The Agent can report own metrics to the destination specified by
    the Server via ConnectionSettingsOffers.own_metrics field.
    Status: [Beta]
    """
    AgentCapabilities_ReportsOwnLogs: _AgentCapabilities.ValueType  # 128
    """The Agent can report own logs to the destination specified by
    the Server via ConnectionSettingsOffers.own_logs field.
    Status: [Beta]
    """
    AgentCapabilities_AcceptsOpAMPConnectionSettings: _AgentCapabilities.ValueType  # 256
    """The can accept connections settings for OpAMP via
    ConnectionSettingsOffers.opamp field.
    Status: [Beta]
    """
    AgentCapabilities_AcceptsOtherConnectionSettings: _AgentCapabilities.ValueType  # 512
    """The can accept connections settings for other destinations via
    ConnectionSettingsOffers.other_connections field.
    Status: [Beta]
    """
    AgentCapabilities_AcceptsRestartCommand: _AgentCapabilities.ValueType  # 1024
    """The Agent can accept restart requests.
    Status: [Beta]
    """
    AgentCapabilities_ReportsHealth: _AgentCapabilities.ValueType  # 2048
    """The Agent will report Health via AgentToServer.health field."""
    AgentCapabilities_ReportsRemoteConfig: _AgentCapabilities.ValueType  # 4096
    """The Agent will report RemoteConfig status via AgentToServer.remote_config_status field."""
    AgentCapabilities_ReportsHeartbeat: _AgentCapabilities.ValueType  # 8192
    """The Agent can report heartbeats.
    This is specified by the ServerToAgent.OpAMPConnectionSettings.heartbeat_interval_seconds field.
    If this capability is true, but the Server does not set a heartbeat_interval_seconds field, the
    Agent should use its own configured interval, which by default will be 30s. The Server may not
    know the configured interval and should not make assumptions about it.
    Status: [Development]
    """
    AgentCapabilities_ReportsAvailableComponents: _AgentCapabilities.ValueType  # 16384
    """The agent will report AvailableComponents via the AgentToServer.available_components field.
    Status: [Development]
    Add new capabilities here, continuing with the least significant unused bit.
    """

class AgentCapabilities(_AgentCapabilities, metaclass=_AgentCapabilitiesEnumTypeWrapper): ...

AgentCapabilities_Unspecified: AgentCapabilities.ValueType  # 0
"""The capabilities field is unspecified."""
AgentCapabilities_ReportsStatus: AgentCapabilities.ValueType  # 1
"""The Agent can report status. This bit MUST be set, since all Agents MUST
report status.
"""
AgentCapabilities_AcceptsRemoteConfig: AgentCapabilities.ValueType  # 2
"""The Agent can accept remote configuration from the Server."""
AgentCapabilities_ReportsEffectiveConfig: AgentCapabilities.ValueType  # 4
"""The Agent will report EffectiveConfig in AgentToServer."""
AgentCapabilities_AcceptsPackages: AgentCapabilities.ValueType  # 8
"""The Agent can accept package offers.
Status: [Beta]
"""
AgentCapabilities_ReportsPackageStatuses: AgentCapabilities.ValueType  # 16
"""The Agent can report package status.
Status: [Beta]
"""
AgentCapabilities_ReportsOwnTraces: AgentCapabilities.ValueType  # 32
"""The Agent can report own trace to the destination specified by
the Server via ConnectionSettingsOffers.own_traces field.
Status: [Beta]
"""
AgentCapabilities_ReportsOwnMetrics: AgentCapabilities.ValueType  # 64
"""The Agent can report own metrics to the destination specified by
the Server via ConnectionSettingsOffers.own_metrics field.
Status: [Beta]
"""
AgentCapabilities_ReportsOwnLogs: AgentCapabilities.ValueType  # 128
"""The Agent can report own logs to the destination specified by
the Server via ConnectionSettingsOffers.own_logs field.
Status: [Beta]
"""
AgentCapabilities_AcceptsOpAMPConnectionSettings: AgentCapabilities.ValueType  # 256
"""The can accept connections settings for OpAMP via
ConnectionSettingsOffers.opamp field.
Status: [Beta]
"""
AgentCapabilities_AcceptsOtherConnectionSettings: AgentCapabilities.ValueType  # 512
"""The can accept connections settings for other destinations via
ConnectionSettingsOffers.other_connections field.
Status: [Beta]
"""
AgentCapabilities_AcceptsRestartCommand: AgentCapabilities.ValueType  # 1024
"""The Agent can accept restart requests.
Status: [Beta]
"""
AgentCapabilities_ReportsHealth: AgentCapabilities.ValueType  # 2048
"""The Agent will report Health via AgentToServer.health field."""
AgentCapabilities_ReportsRemoteConfig: AgentCapabilities.ValueType  # 4096
"""The Agent will report RemoteConfig status via AgentToServer.remote_config_status field."""
AgentCapabilities_ReportsHeartbeat: AgentCapabilities.ValueType  # 8192
"""The Agent can report heartbeats.
This is specified by the ServerToAgent.OpAMPConnectionSettings.heartbeat_interval_seconds field.
If this capability is true, but the Server does not set a heartbeat_interval_seconds field, the
Agent should use its own configured interval, which by default will be 30s. The Server may not
know the configured interval and should not make assumptions about it.
Status: [Development]
"""
AgentCapabilities_ReportsAvailableComponents: AgentCapabilities.ValueType  # 16384
"""The agent will report AvailableComponents via the AgentToServer.available_components field.
Status: [Development]
Add new capabilities here, continuing with the least significant unused bit.
"""
global___AgentCapabilities = AgentCapabilities

class _RemoteConfigStatuses:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _RemoteConfigStatusesEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RemoteConfigStatuses.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    RemoteConfigStatuses_UNSET: _RemoteConfigStatuses.ValueType  # 0
    """The value of status field is not set."""
    RemoteConfigStatuses_APPLIED: _RemoteConfigStatuses.ValueType  # 1
    """Remote config was successfully applied by the Agent."""
    RemoteConfigStatuses_APPLYING: _RemoteConfigStatuses.ValueType  # 2
    """Agent is currently applying the remote config that it received earlier."""
    RemoteConfigStatuses_FAILED: _RemoteConfigStatuses.ValueType  # 3
    """Agent tried to apply the config received earlier, but it failed.
    See error_message for more details.
    """

class RemoteConfigStatuses(_RemoteConfigStatuses, metaclass=_RemoteConfigStatusesEnumTypeWrapper): ...

RemoteConfigStatuses_UNSET: RemoteConfigStatuses.ValueType  # 0
"""The value of status field is not set."""
RemoteConfigStatuses_APPLIED: RemoteConfigStatuses.ValueType  # 1
"""Remote config was successfully applied by the Agent."""
RemoteConfigStatuses_APPLYING: RemoteConfigStatuses.ValueType  # 2
"""Agent is currently applying the remote config that it received earlier."""
RemoteConfigStatuses_FAILED: RemoteConfigStatuses.ValueType  # 3
"""Agent tried to apply the config received earlier, but it failed.
See error_message for more details.
"""
global___RemoteConfigStatuses = RemoteConfigStatuses

class _PackageStatusEnum:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _PackageStatusEnumEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PackageStatusEnum.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    PackageStatusEnum_Installed: _PackageStatusEnum.ValueType  # 0
    """Package is successfully installed by the Agent.
    The error_message field MUST NOT be set.
    """
    PackageStatusEnum_InstallPending: _PackageStatusEnum.ValueType  # 1
    """Installation of this package has not yet started."""
    PackageStatusEnum_Installing: _PackageStatusEnum.ValueType  # 2
    """Agent is currently installing the package.
    server_offered_hash field MUST be set to indicate the version that the
    Agent is installing. The error_message field MUST NOT be set.
    """
    PackageStatusEnum_InstallFailed: _PackageStatusEnum.ValueType  # 3
    """Agent tried to install the package but installation failed.
    server_offered_hash field MUST be set to indicate the version that the Agent
    tried to install. The error_message may also contain more details about
    the failure.
    """
    PackageStatusEnum_Downloading: _PackageStatusEnum.ValueType  # 4
    """Agent is currently downloading the package.
    server_offered_hash field MUST be set to indicate the version that the
    Agent is installing. The error_message field MUST NOT be set.
    Status: [Development]
    """

class PackageStatusEnum(_PackageStatusEnum, metaclass=_PackageStatusEnumEnumTypeWrapper):
    """The status of this package.
    Status: [Beta]
    """

PackageStatusEnum_Installed: PackageStatusEnum.ValueType  # 0
"""Package is successfully installed by the Agent.
The error_message field MUST NOT be set.
"""
PackageStatusEnum_InstallPending: PackageStatusEnum.ValueType  # 1
"""Installation of this package has not yet started."""
PackageStatusEnum_Installing: PackageStatusEnum.ValueType  # 2
"""Agent is currently installing the package.
server_offered_hash field MUST be set to indicate the version that the
Agent is installing. The error_message field MUST NOT be set.
"""
PackageStatusEnum_InstallFailed: PackageStatusEnum.ValueType  # 3
"""Agent tried to install the package but installation failed.
server_offered_hash field MUST be set to indicate the version that the Agent
tried to install. The error_message may also contain more details about
the failure.
"""
PackageStatusEnum_Downloading: PackageStatusEnum.ValueType  # 4
"""Agent is currently downloading the package.
server_offered_hash field MUST be set to indicate the version that the
Agent is installing. The error_message field MUST NOT be set.
Status: [Development]
"""
global___PackageStatusEnum = PackageStatusEnum

@typing_extensions.final
class AgentToServer(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INSTANCE_UID_FIELD_NUMBER: builtins.int
    SEQUENCE_NUM_FIELD_NUMBER: builtins.int
    AGENT_DESCRIPTION_FIELD_NUMBER: builtins.int
    CAPABILITIES_FIELD_NUMBER: builtins.int
    HEALTH_FIELD_NUMBER: builtins.int
    EFFECTIVE_CONFIG_FIELD_NUMBER: builtins.int
    REMOTE_CONFIG_STATUS_FIELD_NUMBER: builtins.int
    PACKAGE_STATUSES_FIELD_NUMBER: builtins.int
    AGENT_DISCONNECT_FIELD_NUMBER: builtins.int
    FLAGS_FIELD_NUMBER: builtins.int
    CONNECTION_SETTINGS_REQUEST_FIELD_NUMBER: builtins.int
    CUSTOM_CAPABILITIES_FIELD_NUMBER: builtins.int
    CUSTOM_MESSAGE_FIELD_NUMBER: builtins.int
    AVAILABLE_COMPONENTS_FIELD_NUMBER: builtins.int
    instance_uid: builtins.bytes
    """Globally unique identifier of the running instance of the Agent. SHOULD remain
    unchanged for the lifetime of the Agent process.
    MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
    """
    sequence_num: builtins.int
    """The sequence number is incremented by 1 for every AgentToServer sent
    by the Agent. This allows the Server to detect that it missed a message when
    it notices that the sequence_num is not exactly by 1 greater than the previously
    received one.
    """
    @property
    def agent_description(self) -> global___AgentDescription:
        """Data that describes the Agent, its type, where it runs, etc.
        May be omitted if nothing changed since last AgentToServer message.
        """
    capabilities: builtins.int
    """Bitmask of flags defined by AgentCapabilities enum.
    All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
    the Agent. This allows extending the protocol and the AgentCapabilities enum
    in the future such that old Agents automatically report that they don't
    support the new capability.
    This field MUST be always set.
    """
    @property
    def health(self) -> global___ComponentHealth:
        """The current health of the Agent and sub-components. The top-level ComponentHealth represents
        the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
        message.
        Status: [Beta]
        """
    @property
    def effective_config(self) -> global___EffectiveConfig:
        """The current effective configuration of the Agent. The effective configuration is
        the one that is currently used by the Agent. The effective configuration may be
        different from the remote configuration received from the Server earlier, e.g.
        because the Agent uses a local configuration instead (or in addition).

        This field SHOULD be unset if the effective config is unchanged since the last
        AgentToServer message.
        """
    @property
    def remote_config_status(self) -> global___RemoteConfigStatus:
        """The status of the remote config that was previously received from the Server.
        This field SHOULD be unset if the remote config status is unchanged since the
        last AgentToServer message.
        """
    @property
    def package_statuses(self) -> global___PackageStatuses:
        """The list of the Agent packages, including package statuses. This field SHOULD be
        unset if this information is unchanged since the last AgentToServer message for
        this Agent was sent in the stream.
        Status: [Beta]
        """
    @property
    def agent_disconnect(self) -> global___AgentDisconnect:
        """AgentDisconnect MUST be set in the last AgentToServer message sent from the
        Agent to the Server.
        """
    flags: builtins.int
    """Bit flags as defined by AgentToServerFlags bit masks."""
    @property
    def connection_settings_request(self) -> global___ConnectionSettingsRequest:
        """A request to create connection settings. This field is set for flows where
        the Agent initiates the creation of connection settings.
        Status: [Development]
        """
    @property
    def custom_capabilities(self) -> global___CustomCapabilities:
        """A message indicating custom capabilities supported by the Agent.
        Status: [Development]
        """
    @property
    def custom_message(self) -> global___CustomMessage:
        """A custom message sent from an Agent to the Server.
        Status: [Development]
        """
    @property
    def available_components(self) -> global___AvailableComponents:
        """A message indicating the components that are available for configuration on the agent.
        Status: [Development]
        """
    def __init__(
        self,
        *,
        instance_uid: builtins.bytes = ...,
        sequence_num: builtins.int = ...,
        agent_description: global___AgentDescription | None = ...,
        capabilities: builtins.int = ...,
        health: global___ComponentHealth | None = ...,
        effective_config: global___EffectiveConfig | None = ...,
        remote_config_status: global___RemoteConfigStatus | None = ...,
        package_statuses: global___PackageStatuses | None = ...,
        agent_disconnect: global___AgentDisconnect | None = ...,
        flags: builtins.int = ...,
        connection_settings_request: global___ConnectionSettingsRequest | None = ...,
        custom_capabilities: global___CustomCapabilities | None = ...,
        custom_message: global___CustomMessage | None = ...,
        available_components: global___AvailableComponents | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["agent_description", b"agent_description", "agent_disconnect", b"agent_disconnect", "available_components", b"available_components", "connection_settings_request", b"connection_settings_request", "custom_capabilities", b"custom_capabilities", "custom_message", b"custom_message", "effective_config", b"effective_config", "health", b"health", "package_statuses", b"package_statuses", "remote_config_status", b"remote_config_status"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["agent_description", b"agent_description", "agent_disconnect", b"agent_disconnect", "available_components", b"available_components", "capabilities", b"capabilities", "connection_settings_request", b"connection_settings_request", "custom_capabilities", b"custom_capabilities", "custom_message", b"custom_message", "effective_config", b"effective_config", "flags", b"flags", "health", b"health", "instance_uid", b"instance_uid", "package_statuses", b"package_statuses", "remote_config_status", b"remote_config_status", "sequence_num", b"sequence_num"]) -> None: ...

global___AgentToServer = AgentToServer

@typing_extensions.final
class AgentDisconnect(google.protobuf.message.Message):
    """AgentDisconnect is the last message sent from the Agent to the Server. The Server
    SHOULD forget the association of the Agent instance with the message stream.

    If the message stream is closed in the transport layer then the Server SHOULD
    forget association of all Agent instances that were previously established for
    this message stream using AgentConnect message, even if the corresponding
    AgentDisconnect message were not explicitly received from the Agent.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___AgentDisconnect = AgentDisconnect

@typing_extensions.final
class ConnectionSettingsRequest(google.protobuf.message.Message):
    """ConnectionSettingsRequest is a request from the Agent to the Server to create
    and respond with an offer of connection settings for the Agent.
    Status: [Development]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OPAMP_FIELD_NUMBER: builtins.int
    @property
    def opamp(self) -> global___OpAMPConnectionSettingsRequest:
        """Request for OpAMP connection settings. If this field is unset
        then the ConnectionSettingsRequest message is empty and is not actionable
        for the Server.
        """
    def __init__(
        self,
        *,
        opamp: global___OpAMPConnectionSettingsRequest | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["opamp", b"opamp"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["opamp", b"opamp"]) -> None: ...

global___ConnectionSettingsRequest = ConnectionSettingsRequest

@typing_extensions.final
class OpAMPConnectionSettingsRequest(google.protobuf.message.Message):
    """OpAMPConnectionSettingsRequest is a request for the Server to produce
    a OpAMPConnectionSettings in its response.
    Status: [Development]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CERTIFICATE_REQUEST_FIELD_NUMBER: builtins.int
    @property
    def certificate_request(self) -> global___CertificateRequest:
        """A request to create a client certificate. This is used to initiate a
        Client Signing Request (CSR) flow.
        Required.
        """
    def __init__(
        self,
        *,
        certificate_request: global___CertificateRequest | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["certificate_request", b"certificate_request"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["certificate_request", b"certificate_request"]) -> None: ...

global___OpAMPConnectionSettingsRequest = OpAMPConnectionSettingsRequest

@typing_extensions.final
class CertificateRequest(google.protobuf.message.Message):
    """Status: [Development]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CSR_FIELD_NUMBER: builtins.int
    csr: builtins.bytes
    """PEM-encoded Client Certificate Signing Request (CSR), signed by client's private key.
    The Server SHOULD validate the request and SHOULD respond with a
    OpAMPConnectionSettings where the certificate.cert contains the issued
    certificate.
    """
    def __init__(
        self,
        *,
        csr: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["csr", b"csr"]) -> None: ...

global___CertificateRequest = CertificateRequest

@typing_extensions.final
class AvailableComponents(google.protobuf.message.Message):
    """AvailableComponents contains metadata relating to the components included
    within the agent.
    status: [Development]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class ComponentsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___ComponentDetails: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___ComponentDetails | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    COMPONENTS_FIELD_NUMBER: builtins.int
    HASH_FIELD_NUMBER: builtins.int
    @property
    def components(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___ComponentDetails]:
        """A map of a unique component ID to details about the component.
        This may be omitted from the message if the server has not
        explicitly requested it be sent by setting the ReportAvailableComponents
        flag in the previous ServerToAgent message.
        """
    hash: builtins.bytes
    """Agent-calculated hash of the components.
    This hash should be included in every AvailableComponents message.
    """
    def __init__(
        self,
        *,
        components: collections.abc.Mapping[builtins.str, global___ComponentDetails] | None = ...,
        hash: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["components", b"components", "hash", b"hash"]) -> None: ...

global___AvailableComponents = AvailableComponents

@typing_extensions.final
class ComponentDetails(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class SubComponentMapEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___ComponentDetails: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___ComponentDetails | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    METADATA_FIELD_NUMBER: builtins.int
    SUB_COMPONENT_MAP_FIELD_NUMBER: builtins.int
    @property
    def metadata(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[anyvalue_pb2.KeyValue]:
        """Extra key/value pairs that may be used to describe the component.
        The key/value pairs are according to semantic conventions, see:
        https://opentelemetry.io/docs/specs/semconv/

        For example, you may use the "code" semantic conventions to
        report the location of the code for a specific component:
        https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/

        Or you may use the "vcs" semantic conventions to report the
        repository the component may be a part of:
        https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
        """
    @property
    def sub_component_map(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___ComponentDetails]:
        """A map of component ID to sub components details. It can nest as deeply as needed to
        describe the underlying system.
        """
    def __init__(
        self,
        *,
        metadata: collections.abc.Iterable[anyvalue_pb2.KeyValue] | None = ...,
        sub_component_map: collections.abc.Mapping[builtins.str, global___ComponentDetails] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["metadata", b"metadata", "sub_component_map", b"sub_component_map"]) -> None: ...

global___ComponentDetails = ComponentDetails

@typing_extensions.final
class ServerToAgent(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INSTANCE_UID_FIELD_NUMBER: builtins.int
    ERROR_RESPONSE_FIELD_NUMBER: builtins.int
    REMOTE_CONFIG_FIELD_NUMBER: builtins.int
    CONNECTION_SETTINGS_FIELD_NUMBER: builtins.int
    PACKAGES_AVAILABLE_FIELD_NUMBER: builtins.int
    FLAGS_FIELD_NUMBER: builtins.int
    CAPABILITIES_FIELD_NUMBER: builtins.int
    AGENT_IDENTIFICATION_FIELD_NUMBER: builtins.int
    COMMAND_FIELD_NUMBER: builtins.int
    CUSTOM_CAPABILITIES_FIELD_NUMBER: builtins.int
    CUSTOM_MESSAGE_FIELD_NUMBER: builtins.int
    instance_uid: builtins.bytes
    """Agent instance uid. MUST match the instance_uid field in AgentToServer message.
    Used for multiplexing messages from/to multiple agents using one message stream.
    """
    @property
    def error_response(self) -> global___ServerErrorResponse:
        """error_response is set if the Server wants to indicate that something went wrong
        during processing of an AgentToServer message. If error_response is set then
        all other fields below must be unset and vice versa, if any of the fields below is
        set then error_response must be unset.
        """
    @property
    def remote_config(self) -> global___AgentRemoteConfig:
        """remote_config field is set when the Server has a remote config offer for the Agent."""
    @property
    def connection_settings(self) -> global___ConnectionSettingsOffers:
        """This field is set when the Server wants the Agent to change one or more
        of its client connection settings (destination, headers, certificate, etc).
        Status: [Beta]
        """
    @property
    def packages_available(self) -> global___PackagesAvailable:
        """This field is set when the Server has packages to offer to the Agent.
        Status: [Beta]
        """
    flags: builtins.int
    """Bit flags as defined by ServerToAgentFlags bit masks."""
    capabilities: builtins.int
    """Bitmask of flags defined by ServerCapabilities enum.
    All bits that are not defined in ServerCapabilities enum MUST be set to 0
    by the Server. This allows extending the protocol and the ServerCapabilities
    enum in the future such that old Servers automatically report that they
    don't support the new capability.
    This field MUST be set in the first ServerToAgent sent by the Server and MAY
    be omitted in subsequent ServerToAgent messages by setting it to
    UnspecifiedServerCapability value.
    """
    @property
    def agent_identification(self) -> global___AgentIdentification:
        """Properties related to identification of the Agent, which can be overridden
        by the Server if needed.
        """
    @property
    def command(self) -> global___ServerToAgentCommand:
        """Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
        with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
        will be performed.
        Status: [Beta]
        """
    @property
    def custom_capabilities(self) -> global___CustomCapabilities:
        """A message indicating custom capabilities supported by the Server.
        Status: [Development]
        """
    @property
    def custom_message(self) -> global___CustomMessage:
        """A custom message sent from the Server to an Agent.
        Status: [Development]
        """
    def __init__(
        self,
        *,
        instance_uid: builtins.bytes = ...,
        error_response: global___ServerErrorResponse | None = ...,
        remote_config: global___AgentRemoteConfig | None = ...,
        connection_settings: global___ConnectionSettingsOffers | None = ...,
        packages_available: global___PackagesAvailable | None = ...,
        flags: builtins.int = ...,
        capabilities: builtins.int = ...,
        agent_identification: global___AgentIdentification | None = ...,
        command: global___ServerToAgentCommand | None = ...,
        custom_capabilities: global___CustomCapabilities | None = ...,
        custom_message: global___CustomMessage | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["agent_identification", b"agent_identification", "command", b"command", "connection_settings", b"connection_settings", "custom_capabilities", b"custom_capabilities", "custom_message", b"custom_message", "error_response", b"error_response", "packages_available", b"packages_available", "remote_config", b"remote_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["agent_identification", b"agent_identification", "capabilities", b"capabilities", "command", b"command", "connection_settings", b"connection_settings", "custom_capabilities", b"custom_capabilities", "custom_message", b"custom_message", "error_response", b"error_response", "flags", b"flags", "instance_uid", b"instance_uid", "packages_available", b"packages_available", "remote_config", b"remote_config"]) -> None: ...

global___ServerToAgent = ServerToAgent

@typing_extensions.final
class OpAMPConnectionSettings(google.protobuf.message.Message):
    """The OpAMPConnectionSettings message is a collection of fields which comprise an
    offer from the Server to the Agent to use the specified settings for OpAMP
    connection.
    Status: [Beta]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DESTINATION_ENDPOINT_FIELD_NUMBER: builtins.int
    HEADERS_FIELD_NUMBER: builtins.int
    CERTIFICATE_FIELD_NUMBER: builtins.int
    HEARTBEAT_INTERVAL_SECONDS_FIELD_NUMBER: builtins.int
    destination_endpoint: builtins.str
    """OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
    example: "wss://example.com:4318/v1/opamp"
    """
    @property
    def headers(self) -> global___Headers:
        """Optional headers to use when connecting. Typically used to set access tokens or
        other authorization headers. For HTTP-based protocols the Agent should
        set these in the request headers.
        For example:
        key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
        """
    @property
    def certificate(self) -> global___TLSCertificate:
        """The Agent should use the offered certificate to connect to the destination
        from now on. If the Agent is able to validate and connect using the offered
        certificate the Agent SHOULD forget any previous client certificates
        for this connection.
        This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
        This field can be used to perform a client certificate revocation/rotation.
        """
    heartbeat_interval_seconds: builtins.int
    """The Agent MUST periodically send an AgentToServer message if the
    AgentCapabilities_ReportsHeartbeat capability is true. At a minimum the instance_uid
    field MUST be set.

    An HTTP Client MUST use the value as polling interval, if heartbeat_interval_seconds is non-zero.

    A heartbeat is used to keep the connection active and inform the server that the Agent
    is still alive and active.

    If this field has no value or is set to 0, the Agent should not send any heartbeats.
    Status: [Development]
    """
    def __init__(
        self,
        *,
        destination_endpoint: builtins.str = ...,
        headers: global___Headers | None = ...,
        certificate: global___TLSCertificate | None = ...,
        heartbeat_interval_seconds: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["certificate", b"certificate", "headers", b"headers"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["certificate", b"certificate", "destination_endpoint", b"destination_endpoint", "headers", b"headers", "heartbeat_interval_seconds", b"heartbeat_interval_seconds"]) -> None: ...

global___OpAMPConnectionSettings = OpAMPConnectionSettings

@typing_extensions.final
class TelemetryConnectionSettings(google.protobuf.message.Message):
    """The TelemetryConnectionSettings message is a collection of fields which comprise an
    offer from the Server to the Agent to use the specified settings for a network
    connection to report own telemetry.
    Status: [Beta]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DESTINATION_ENDPOINT_FIELD_NUMBER: builtins.int
    HEADERS_FIELD_NUMBER: builtins.int
    CERTIFICATE_FIELD_NUMBER: builtins.int
    destination_endpoint: builtins.str
    """The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
    SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
    The Agent MAY refuse to send the telemetry if the URL begins with "http://".
    """
    @property
    def headers(self) -> global___Headers:
        """Optional headers to use when connecting. Typically used to set access tokens or
        other authorization headers. For HTTP-based protocols the Agent should
        set these in the request headers.
        For example:
        key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
        """
    @property
    def certificate(self) -> global___TLSCertificate:
        """The Agent should use the offered certificate to connect to the destination
        from now on. If the Agent is able to validate and connect using the offered
        certificate the Agent SHOULD forget any previous client certificates
        for this connection.
        This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
        This field can be used to perform a client certificate revocation/rotation.
        """
    def __init__(
        self,
        *,
        destination_endpoint: builtins.str = ...,
        headers: global___Headers | None = ...,
        certificate: global___TLSCertificate | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["certificate", b"certificate", "headers", b"headers"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["certificate", b"certificate", "destination_endpoint", b"destination_endpoint", "headers", b"headers"]) -> None: ...

global___TelemetryConnectionSettings = TelemetryConnectionSettings

@typing_extensions.final
class OtherConnectionSettings(google.protobuf.message.Message):
    """The OtherConnectionSettings message is a collection of fields which comprise an
    offer from the Server to the Agent to use the specified settings for a network
    connection. It is not required that all fields in this message are specified.
    The Server may specify only some of the fields, in which case it means that
    the Server offers the Agent to change only those fields, while keeping the
    rest of the fields unchanged.

    For example the Server may send a ConnectionSettings message with only the
    certificate field set, while all other fields are unset. This means that
    the Server wants the Agent to use a new certificate and continue sending to
    the destination it is currently sending using the current header and other
    settings.

    For fields which reference other messages the field is considered unset
    when the reference is unset.

    For primitive field (string) we rely on the "flags" to describe that the
    field is not set (this is done to overcome the limitation of old protoc
    compilers don't generate methods that allow to check for the presence of
    the field.
    Status: [Beta]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class OtherSettingsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    DESTINATION_ENDPOINT_FIELD_NUMBER: builtins.int
    HEADERS_FIELD_NUMBER: builtins.int
    CERTIFICATE_FIELD_NUMBER: builtins.int
    OTHER_SETTINGS_FIELD_NUMBER: builtins.int
    destination_endpoint: builtins.str
    """A URL, host:port or some other destination specifier."""
    @property
    def headers(self) -> global___Headers:
        """Optional headers to use when connecting. Typically used to set access tokens or
        other authorization headers. For HTTP-based protocols the Agent should
        set these in the request headers.
        For example:
        key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
        """
    @property
    def certificate(self) -> global___TLSCertificate:
        """The Agent should use the offered certificate to connect to the destination
        from now on. If the Agent is able to validate and connect using the offered
        certificate the Agent SHOULD forget any previous client certificates
        for this connection.
        This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
        This field can be used to perform a client certificate revocation/rotation.
        """
    @property
    def other_settings(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Other connection settings. These are Agent-specific and are up to the Agent
        interpret.
        """
    def __init__(
        self,
        *,
        destination_endpoint: builtins.str = ...,
        headers: global___Headers | None = ...,
        certificate: global___TLSCertificate | None = ...,
        other_settings: collections.abc.Mapping[builtins.str, builtins.str] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["certificate", b"certificate", "headers", b"headers"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["certificate", b"certificate", "destination_endpoint", b"destination_endpoint", "headers", b"headers", "other_settings", b"other_settings"]) -> None: ...

global___OtherConnectionSettings = OtherConnectionSettings

@typing_extensions.final
class Headers(google.protobuf.message.Message):
    """Status: [Beta]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HEADERS_FIELD_NUMBER: builtins.int
    @property
    def headers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Header]: ...
    def __init__(
        self,
        *,
        headers: collections.abc.Iterable[global___Header] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["headers", b"headers"]) -> None: ...

global___Headers = Headers

@typing_extensions.final
class Header(google.protobuf.message.Message):
    """Status: [Beta]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    key: builtins.str
    value: builtins.str
    def __init__(
        self,
        *,
        key: builtins.str = ...,
        value: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

global___Header = Header

@typing_extensions.final
class TLSCertificate(google.protobuf.message.Message):
    """Status: [Beta]
    The (cert,private_key) pair should be issued and signed by a Certificate
    Authority (CA) that the destination Server recognizes.

    It is highly recommended that the private key of the CA certificate is NOT
    stored on the destination Server otherwise compromising the Server will allow
    a malicious actor to issue valid Server certificates which will be automatically
    trusted by all agents and will allow the actor to trivially MITM Agent-to-Server
    traffic of all servers that use this CA certificate for their Server-side
    certificates.

    Alternatively the certificate may be self-signed, assuming the Server can
    verify the certificate.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CERT_FIELD_NUMBER: builtins.int
    PRIVATE_KEY_FIELD_NUMBER: builtins.int
    CA_CERT_FIELD_NUMBER: builtins.int
    cert: builtins.bytes
    """PEM-encoded certificate. Required."""
    private_key: builtins.bytes
    """PEM-encoded private key of the certificate. Required."""
    ca_cert: builtins.bytes
    """PEM-encoded certificate of the signing CA.
    Optional. MUST be specified if the certificate is CA-signed.
    Can be stored by TLS-terminating intermediary proxies in order to verify
    the connecting client's certificate in the future.
    It is not recommended that the Agent accepts this CA as an authority for
    any purposes.
    """
    def __init__(
        self,
        *,
        cert: builtins.bytes = ...,
        private_key: builtins.bytes = ...,
        ca_cert: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["ca_cert", b"ca_cert", "cert", b"cert", "private_key", b"private_key"]) -> None: ...

global___TLSCertificate = TLSCertificate

@typing_extensions.final
class ConnectionSettingsOffers(google.protobuf.message.Message):
    """Status: [Beta]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class OtherConnectionsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___OtherConnectionSettings: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___OtherConnectionSettings | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    HASH_FIELD_NUMBER: builtins.int
    OPAMP_FIELD_NUMBER: builtins.int
    OWN_METRICS_FIELD_NUMBER: builtins.int
    OWN_TRACES_FIELD_NUMBER: builtins.int
    OWN_LOGS_FIELD_NUMBER: builtins.int
    OTHER_CONNECTIONS_FIELD_NUMBER: builtins.int
    hash: builtins.bytes
    """Hash of all settings, including settings that may be omitted from this message
    because they are unchanged.
    """
    @property
    def opamp(self) -> global___OpAMPConnectionSettings:
        """Settings to connect to the OpAMP Server.
        If this field is not set then the Agent should assume that the settings are
        unchanged and should continue using existing settings.
        The Agent MUST verify the offered connection settings by actually connecting
        before accepting the setting to ensure it does not loose access to the OpAMP
        Server due to invalid settings.
        """
    @property
    def own_metrics(self) -> global___TelemetryConnectionSettings:
        """Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
        If this field is not set then the Agent should assume that the settings
        are unchanged.

        Once accepted the Agent should periodically send to the specified destination
        its own metrics, i.e. metrics of the Agent process and any custom metrics that
        describe the Agent state.

        All attributes specified in the identifying_attributes field in AgentDescription
        message SHOULD be also specified in the Resource of the reported OTLP metrics.

        Attributes specified in the non_identifying_attributes field in
        AgentDescription message may be also specified in the Resource of the reported
        OTLP metrics, in which case they SHOULD have exactly the same values.

        Process metrics MUST follow the conventions for processes:
        https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
        """
    @property
    def own_traces(self) -> global___TelemetryConnectionSettings:
        """Similar to own_metrics, but for traces."""
    @property
    def own_logs(self) -> global___TelemetryConnectionSettings:
        """Similar to own_metrics, but for logs."""
    @property
    def other_connections(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___OtherConnectionSettings]:
        """Another set of connection settings, with a string name associated with each.
        How the Agent uses these is Agent-specific. Typically the name represents
        the name of the destination to connect to (as it is known to the Agent).
        If this field is not set then the Agent should assume that the other_connections
        settings are unchanged.
        """
    def __init__(
        self,
        *,
        hash: builtins.bytes = ...,
        opamp: global___OpAMPConnectionSettings | None = ...,
        own_metrics: global___TelemetryConnectionSettings | None = ...,
        own_traces: global___TelemetryConnectionSettings | None = ...,
        own_logs: global___TelemetryConnectionSettings | None = ...,
        other_connections: collections.abc.Mapping[builtins.str, global___OtherConnectionSettings] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["opamp", b"opamp", "own_logs", b"own_logs", "own_metrics", b"own_metrics", "own_traces", b"own_traces"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["hash", b"hash", "opamp", b"opamp", "other_connections", b"other_connections", "own_logs", b"own_logs", "own_metrics", b"own_metrics", "own_traces", b"own_traces"]) -> None: ...

global___ConnectionSettingsOffers = ConnectionSettingsOffers

@typing_extensions.final
class PackagesAvailable(google.protobuf.message.Message):
    """List of packages that the Server offers to the Agent.
    Status: [Beta]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class PackagesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___PackageAvailable: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___PackageAvailable | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    PACKAGES_FIELD_NUMBER: builtins.int
    ALL_PACKAGES_HASH_FIELD_NUMBER: builtins.int
    @property
    def packages(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___PackageAvailable]:
        """Map of packages. Keys are package names, values are the packages available for download."""
    all_packages_hash: builtins.bytes
    """Aggregate hash of all remotely installed packages. The Agent SHOULD include this
    value in subsequent PackageStatuses messages. This in turn allows the management
    Server to identify that a different set of packages is available for the Agent
    and specify the available packages in the next ServerToAgent message.

    This field MUST be always set if the management Server supports packages
    of agents.

    The hash is calculated as an aggregate of all packages names and content.
    """
    def __init__(
        self,
        *,
        packages: collections.abc.Mapping[builtins.str, global___PackageAvailable] | None = ...,
        all_packages_hash: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["all_packages_hash", b"all_packages_hash", "packages", b"packages"]) -> None: ...

global___PackagesAvailable = PackagesAvailable

@typing_extensions.final
class PackageAvailable(google.protobuf.message.Message):
    """Each Agent is composed of one or more packages. A package has a name and
    content stored in a file. The content of the files, functionality
    provided by the packages, how they are stored and used by the Agent side is Agent
    type-specific and is outside the concerns of the OpAMP protocol.

    If the Agent does not have an installed package with the specified name then
    it SHOULD download it from the specified URL and install it.

    If the Agent already has an installed package with the specified name
    but with a different hash then the Agent SHOULD download and
    install the package again, since it is a different version of the same package.

    If the Agent has an installed package with the specified name and the same
    hash then the Agent does not need to do anything, it already
    has the right version of the package.
    Status: [Beta]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    FILE_FIELD_NUMBER: builtins.int
    HASH_FIELD_NUMBER: builtins.int
    type: global___PackageType.ValueType
    version: builtins.str
    """The package version that is available on the Server side. The Agent may for
    example use this information to avoid downloading a package that was previously
    already downloaded and failed to install.
    """
    @property
    def file(self) -> global___DownloadableFile:
        """The downloadable file of the package."""
    hash: builtins.bytes
    """The hash of the package. SHOULD be calculated based on all other fields of the
    PackageAvailable message and content of the file of the package. The hash is
    used by the Agent to determine if the package it has is different from the
    package the Server is offering.
    """
    def __init__(
        self,
        *,
        type: global___PackageType.ValueType = ...,
        version: builtins.str = ...,
        file: global___DownloadableFile | None = ...,
        hash: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["file", b"file"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["file", b"file", "hash", b"hash", "type", b"type", "version", b"version"]) -> None: ...

global___PackageAvailable = PackageAvailable

@typing_extensions.final
class DownloadableFile(google.protobuf.message.Message):
    """Status: [Beta]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DOWNLOAD_URL_FIELD_NUMBER: builtins.int
    CONTENT_HASH_FIELD_NUMBER: builtins.int
    SIGNATURE_FIELD_NUMBER: builtins.int
    HEADERS_FIELD_NUMBER: builtins.int
    download_url: builtins.str
    """The URL from which the file can be downloaded using HTTP GET request.
    The Server at the specified URL SHOULD support range requests
    to allow for resuming downloads.
    """
    content_hash: builtins.bytes
    """The hash of the file content. Can be used by the Agent to verify that the file
    was downloaded correctly.
    """
    signature: builtins.bytes
    """Optional signature of the file content. Can be used by the Agent to verify the
    authenticity of the downloaded file, for example can be the
    [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
    The exact signing and verification method is Agent specific. See
    https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
    for recommendations.
    """
    @property
    def headers(self) -> global___Headers:
        """Optional headers to use when downloading a file. Typically used to set
        access tokens or other authorization headers. For HTTP-based protocols
        the Agent should set these in the request headers.
        For example:
        key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
        Status: [Development]
        """
    def __init__(
        self,
        *,
        download_url: builtins.str = ...,
        content_hash: builtins.bytes = ...,
        signature: builtins.bytes = ...,
        headers: global___Headers | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["headers", b"headers"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["content_hash", b"content_hash", "download_url", b"download_url", "headers", b"headers", "signature", b"signature"]) -> None: ...

global___DownloadableFile = DownloadableFile

@typing_extensions.final
class ServerErrorResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    ERROR_MESSAGE_FIELD_NUMBER: builtins.int
    RETRY_INFO_FIELD_NUMBER: builtins.int
    type: global___ServerErrorResponseType.ValueType
    error_message: builtins.str
    """Error message in the string form, typically human readable."""
    @property
    def retry_info(self) -> global___RetryInfo:
        """Additional information about retrying if type==UNAVAILABLE."""
    def __init__(
        self,
        *,
        type: global___ServerErrorResponseType.ValueType = ...,
        error_message: builtins.str = ...,
        retry_info: global___RetryInfo | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["Details", b"Details", "retry_info", b"retry_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["Details", b"Details", "error_message", b"error_message", "retry_info", b"retry_info", "type", b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["Details", b"Details"]) -> typing_extensions.Literal["retry_info"] | None: ...

global___ServerErrorResponse = ServerErrorResponse

@typing_extensions.final
class RetryInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RETRY_AFTER_NANOSECONDS_FIELD_NUMBER: builtins.int
    retry_after_nanoseconds: builtins.int
    def __init__(
        self,
        *,
        retry_after_nanoseconds: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["retry_after_nanoseconds", b"retry_after_nanoseconds"]) -> None: ...

global___RetryInfo = RetryInfo

@typing_extensions.final
class ServerToAgentCommand(google.protobuf.message.Message):
    """ServerToAgentCommand is sent from the Server to the Agent to request that the Agent
    perform a command.
    Status: [Beta]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    type: global___CommandType.ValueType
    def __init__(
        self,
        *,
        type: global___CommandType.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["type", b"type"]) -> None: ...

global___ServerToAgentCommand = ServerToAgentCommand

@typing_extensions.final
class AgentDescription(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////////
    Status reporting
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IDENTIFYING_ATTRIBUTES_FIELD_NUMBER: builtins.int
    NON_IDENTIFYING_ATTRIBUTES_FIELD_NUMBER: builtins.int
    @property
    def identifying_attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[anyvalue_pb2.KeyValue]:
        """Attributes that identify the Agent.
        Keys/values are according to OpenTelemetry semantic conventions, see:
        https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions

        For standalone running Agents (such as OpenTelemetry Collector) the following
        attributes SHOULD be specified:
        - service.name should be set to a reverse FQDN that uniquely identifies the
          Agent type, e.g. "io.opentelemetry.collector"
        - service.namespace if it is used in the environment where the Agent runs.
        - service.version should be set to version number of the Agent build.
        - service.instance.id should be set. It may be set equal to the Agent's
          instance uid (equal to ServerToAgent.instance_uid field) or any other value
          that uniquely identifies the Agent in combination with other attributes.
        - any other attributes that are necessary for uniquely identifying the Agent's
          own telemetry.

        The Agent SHOULD also include these attributes in the Resource of its own
        telemetry. The combination of identifying attributes SHOULD be sufficient to
        uniquely identify the Agent's own telemetry in the destination system to which
        the Agent sends its own telemetry.
        """
    @property
    def non_identifying_attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[anyvalue_pb2.KeyValue]:
        """Attributes that do not necessarily identify the Agent but help describe
        where it runs.
        The following attributes SHOULD be included:
        - os.type, os.version - to describe where the Agent runs.
        - host.* to describe the host the Agent runs on.
        - cloud.* to describe the cloud where the host is located.
        - any other relevant Resource attributes that describe this Agent and the
          environment it runs in.
        - any user-defined attributes that the end user would like to associate
          with this Agent.
        """
    def __init__(
        self,
        *,
        identifying_attributes: collections.abc.Iterable[anyvalue_pb2.KeyValue] | None = ...,
        non_identifying_attributes: collections.abc.Iterable[anyvalue_pb2.KeyValue] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["identifying_attributes", b"identifying_attributes", "non_identifying_attributes", b"non_identifying_attributes"]) -> None: ...

global___AgentDescription = AgentDescription

@typing_extensions.final
class ComponentHealth(google.protobuf.message.Message):
    """The health of the Agent and sub-components
    Status: [Beta]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class ComponentHealthMapEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___ComponentHealth: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___ComponentHealth | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    HEALTHY_FIELD_NUMBER: builtins.int
    START_TIME_UNIX_NANO_FIELD_NUMBER: builtins.int
    LAST_ERROR_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    STATUS_TIME_UNIX_NANO_FIELD_NUMBER: builtins.int
    COMPONENT_HEALTH_MAP_FIELD_NUMBER: builtins.int
    healthy: builtins.bool
    """Set to true if the component is up and healthy."""
    start_time_unix_nano: builtins.int
    """Timestamp since the component is up, i.e. when the component was started.
    Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
    If the component is not running MUST be set to 0.
    """
    last_error: builtins.str
    """Human-readable error message if the component is in erroneous state. SHOULD be set
    when healthy==false.
    """
    status: builtins.str
    """Component status represented as a string. The status values are defined by agent-specific
    semantics and not at the protocol level.
    """
    status_time_unix_nano: builtins.int
    """The time when the component status was observed. Value is UNIX Epoch time in
    nanoseconds since 00:00:00 UTC on 1 January 1970.
    """
    @property
    def component_health_map(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___ComponentHealth]:
        """A map to store more granular, sub-component health. It can nest as deeply as needed to
        describe the underlying system.
        """
    def __init__(
        self,
        *,
        healthy: builtins.bool = ...,
        start_time_unix_nano: builtins.int = ...,
        last_error: builtins.str = ...,
        status: builtins.str = ...,
        status_time_unix_nano: builtins.int = ...,
        component_health_map: collections.abc.Mapping[builtins.str, global___ComponentHealth] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["component_health_map", b"component_health_map", "healthy", b"healthy", "last_error", b"last_error", "start_time_unix_nano", b"start_time_unix_nano", "status", b"status", "status_time_unix_nano", b"status_time_unix_nano"]) -> None: ...

global___ComponentHealth = ComponentHealth

@typing_extensions.final
class EffectiveConfig(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONFIG_MAP_FIELD_NUMBER: builtins.int
    @property
    def config_map(self) -> global___AgentConfigMap:
        """The effective config of the Agent."""
    def __init__(
        self,
        *,
        config_map: global___AgentConfigMap | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["config_map", b"config_map"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["config_map", b"config_map"]) -> None: ...

global___EffectiveConfig = EffectiveConfig

@typing_extensions.final
class RemoteConfigStatus(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LAST_REMOTE_CONFIG_HASH_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    ERROR_MESSAGE_FIELD_NUMBER: builtins.int
    last_remote_config_hash: builtins.bytes
    """The hash of the remote config that was last received by this Agent in the
    AgentRemoteConfig.config_hash field.
    The Server SHOULD compare this hash with the config hash
    it has for the Agent and if the hashes are different the Server MUST include
    the remote_config field in the response in the ServerToAgent message.
    """
    status: global___RemoteConfigStatuses.ValueType
    error_message: builtins.str
    """Optional error message if status==FAILED."""
    def __init__(
        self,
        *,
        last_remote_config_hash: builtins.bytes = ...,
        status: global___RemoteConfigStatuses.ValueType = ...,
        error_message: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["error_message", b"error_message", "last_remote_config_hash", b"last_remote_config_hash", "status", b"status"]) -> None: ...

global___RemoteConfigStatus = RemoteConfigStatus

@typing_extensions.final
class PackageStatuses(google.protobuf.message.Message):
    """The PackageStatuses message describes the status of all packages that the Agent
    has or was offered.
    Status: [Beta]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class PackagesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___PackageStatus: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___PackageStatus | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    PACKAGES_FIELD_NUMBER: builtins.int
    SERVER_PROVIDED_ALL_PACKAGES_HASH_FIELD_NUMBER: builtins.int
    ERROR_MESSAGE_FIELD_NUMBER: builtins.int
    @property
    def packages(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___PackageStatus]:
        """A map of PackageStatus messages, where the keys are package names.
        The key MUST match the name field of PackageStatus message.
        """
    server_provided_all_packages_hash: builtins.bytes
    """The aggregate hash of all packages that this Agent previously received from the
    Server via PackagesAvailable message.

    The Server SHOULD compare this hash to the aggregate hash of all packages that
    it has for this Agent and if the hashes are different the Server SHOULD send
    an PackagesAvailable message to the Agent.
    """
    error_message: builtins.str
    """This field is set if the Agent encountered an error when processing the
    PackagesAvailable message and that error is not related to any particular single
    package.
    The field must be unset is there were no processing errors.
    """
    def __init__(
        self,
        *,
        packages: collections.abc.Mapping[builtins.str, global___PackageStatus] | None = ...,
        server_provided_all_packages_hash: builtins.bytes = ...,
        error_message: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["error_message", b"error_message", "packages", b"packages", "server_provided_all_packages_hash", b"server_provided_all_packages_hash"]) -> None: ...

global___PackageStatuses = PackageStatuses

@typing_extensions.final
class PackageStatus(google.protobuf.message.Message):
    """The status of a single package.
    Status: [Beta]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    AGENT_HAS_VERSION_FIELD_NUMBER: builtins.int
    AGENT_HAS_HASH_FIELD_NUMBER: builtins.int
    SERVER_OFFERED_VERSION_FIELD_NUMBER: builtins.int
    SERVER_OFFERED_HASH_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    ERROR_MESSAGE_FIELD_NUMBER: builtins.int
    DOWNLOAD_DETAILS_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Package name. MUST be always set and MUST match the key in the packages field
    of PackageStatuses message.
    """
    agent_has_version: builtins.str
    """The version of the package that the Agent has.
    MUST be set if the Agent has this package.
    MUST be empty if the Agent does not have this package. This may be the case
    for example if the package was offered by the Server but failed to install
    and the Agent did not have this package previously.
    """
    agent_has_hash: builtins.bytes
    """The hash of the package that the Agent has.
    MUST be set if the Agent has this package.
    MUST be empty if the Agent does not have this package. This may be the case for
    example if the package was offered by the Server but failed to install and the
    Agent did not have this package previously.
    """
    server_offered_version: builtins.str
    """The version of the package that the Server offered to the Agent.
    MUST be set if the installation of the package is initiated by an earlier offer
    from the Server to install this package.

    MUST be empty if the Agent has this package but it was installed locally and
    was not offered by the Server.

    Note that it is possible for both agent_has_version and server_offered_version
    fields to be set and to have different values. This is for example possible if
    the Agent already has a version of the package successfully installed, the Server
    offers a different version, but the Agent fails to install that version.
    """
    server_offered_hash: builtins.bytes
    """The hash of the package that the Server offered to the Agent.
    MUST be set if the installation of the package is initiated by an earlier
    offer from the Server to install this package.

    MUST be empty if the Agent has this package but it was installed locally and
    was not offered by the Server.

    Note that it is possible for both agent_has_hash and server_offered_hash
    fields to be set and to have different values. This is for example possible if
    the Agent already has a version of the package successfully installed, the
    Server offers a different version, but the Agent fails to install that version.
    """
    status: global___PackageStatusEnum.ValueType
    error_message: builtins.str
    """Error message if the status is erroneous."""
    @property
    def download_details(self) -> global___PackageDownloadDetails:
        """Optional details that may be of interest to a user.
        Should only be set if status is Downloading.
        Status: [Development]
        """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        agent_has_version: builtins.str = ...,
        agent_has_hash: builtins.bytes = ...,
        server_offered_version: builtins.str = ...,
        server_offered_hash: builtins.bytes = ...,
        status: global___PackageStatusEnum.ValueType = ...,
        error_message: builtins.str = ...,
        download_details: global___PackageDownloadDetails | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["download_details", b"download_details"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["agent_has_hash", b"agent_has_hash", "agent_has_version", b"agent_has_version", "download_details", b"download_details", "error_message", b"error_message", "name", b"name", "server_offered_hash", b"server_offered_hash", "server_offered_version", b"server_offered_version", "status", b"status"]) -> None: ...

global___PackageStatus = PackageStatus

@typing_extensions.final
class PackageDownloadDetails(google.protobuf.message.Message):
    """Additional details that an agent can use to describe an in-progress package download.
    Status: [Development]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DOWNLOAD_PERCENT_FIELD_NUMBER: builtins.int
    DOWNLOAD_BYTES_PER_SECOND_FIELD_NUMBER: builtins.int
    download_percent: builtins.float
    """The package download progress as a percentage."""
    download_bytes_per_second: builtins.float
    """The current package download rate in bytes per second."""
    def __init__(
        self,
        *,
        download_percent: builtins.float = ...,
        download_bytes_per_second: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["download_bytes_per_second", b"download_bytes_per_second", "download_percent", b"download_percent"]) -> None: ...

global___PackageDownloadDetails = PackageDownloadDetails

@typing_extensions.final
class AgentIdentification(google.protobuf.message.Message):
    """Properties related to identification of the Agent, which can be overridden
    by the Server if needed
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NEW_INSTANCE_UID_FIELD_NUMBER: builtins.int
    new_instance_uid: builtins.bytes
    """When new_instance_uid is set, Agent MUST update instance_uid
    to the value provided and use it for all further communication.
    MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
    """
    def __init__(
        self,
        *,
        new_instance_uid: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["new_instance_uid", b"new_instance_uid"]) -> None: ...

global___AgentIdentification = AgentIdentification

@typing_extensions.final
class AgentRemoteConfig(google.protobuf.message.Message):
    """///////////////////////////////////////////////////////////////////////////////////
    Config messages
    ///////////////////////////////////////////////////////////////////////////////////
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONFIG_FIELD_NUMBER: builtins.int
    CONFIG_HASH_FIELD_NUMBER: builtins.int
    @property
    def config(self) -> global___AgentConfigMap:
        """Agent config offered by the management Server to the Agent instance. SHOULD NOT be
        set if the config for this Agent has not changed since it was last requested (i.e.
        AgentConfigRequest.last_remote_config_hash field is equal to
        AgentConfigResponse.config_hash field).
        """
    config_hash: builtins.bytes
    """Hash of "config". The Agent SHOULD include this value in subsequent
    RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
    allows the management Server to identify that a new config is available for the Agent.

    This field MUST be always set if the management Server supports remote configuration
    of agents.

    Management Server must choose a hashing function that guarantees lack of hash
    collisions in practice.
    """
    def __init__(
        self,
        *,
        config: global___AgentConfigMap | None = ...,
        config_hash: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["config", b"config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["config", b"config", "config_hash", b"config_hash"]) -> None: ...

global___AgentRemoteConfig = AgentRemoteConfig

@typing_extensions.final
class AgentConfigMap(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class ConfigMapEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___AgentConfigFile: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___AgentConfigFile | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    CONFIG_MAP_FIELD_NUMBER: builtins.int
    @property
    def config_map(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___AgentConfigFile]:
        """Map of configs. Keys are config file names or config section names.
        The configuration is assumed to be a collection of one or more named config files
        or sections.
        For agents that use a single config file or section the map SHOULD contain a single
        entry and the key may be an empty string.
        """
    def __init__(
        self,
        *,
        config_map: collections.abc.Mapping[builtins.str, global___AgentConfigFile] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["config_map", b"config_map"]) -> None: ...

global___AgentConfigMap = AgentConfigMap

@typing_extensions.final
class AgentConfigFile(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BODY_FIELD_NUMBER: builtins.int
    CONTENT_TYPE_FIELD_NUMBER: builtins.int
    body: builtins.bytes
    """Config file or section body. The content, format and encoding depends on the Agent
    type. The content_type field may optionally describe the MIME type of the body.
    """
    content_type: builtins.str
    """Optional MIME Content-Type that describes what's in the body field, for
    example "text/yaml".
    """
    def __init__(
        self,
        *,
        body: builtins.bytes = ...,
        content_type: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["body", b"body", "content_type", b"content_type"]) -> None: ...

global___AgentConfigFile = AgentConfigFile

@typing_extensions.final
class CustomCapabilities(google.protobuf.message.Message):
    """///////////////////////////////////////////////////////////////////////////////////
    Custom messages
    ///////////////////////////////////////////////////////////////////////////////////
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CAPABILITIES_FIELD_NUMBER: builtins.int
    @property
    def capabilities(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """A list of custom capabilities that are supported. Each capability is a reverse FQDN
        with optional version information that uniquely identifies the custom capability
        and should match a capability specified in a supported CustomMessage.
        Status: [Development]
        """
    def __init__(
        self,
        *,
        capabilities: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["capabilities", b"capabilities"]) -> None: ...

global___CustomCapabilities = CustomCapabilities

@typing_extensions.final
class CustomMessage(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CAPABILITY_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    DATA_FIELD_NUMBER: builtins.int
    capability: builtins.str
    """A reverse FQDN that uniquely identifies the capability and matches one of the
    capabilities in the CustomCapabilities message.
    Status: [Development]
    """
    type: builtins.str
    """Type of message within the capability. The capability defines the types of custom
    messages that are used to implement the capability. The type must only be unique
    within the capability.
    Status: [Development]
    """
    data: builtins.bytes
    """Binary data of the message. The capability must specify the format of the contents
    of the data for each custom message type it defines.
    Status: [Development]
    """
    def __init__(
        self,
        *,
        capability: builtins.str = ...,
        type: builtins.str = ...,
        data: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["capability", b"capability", "data", b"data", "type", b"type"]) -> None: ...

global___CustomMessage = CustomMessage
